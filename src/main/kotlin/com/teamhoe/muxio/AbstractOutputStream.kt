package com.teamhoe.muxio

import java.io.IOException
import java.io.OutputStream

/**
 * used to multiplex and write data into the underlying shared
 * [multiplexedOutputStream] that other [AbstractOutputStream]s also write
 * into. The data written by this stream into the [multiplexedOutputStream] is
 * always immediately preceded by headers generated by the [headerFactory].
 *
 * @param multiplexedOutputStream the [OutputStream] that data should be
 * multiplexed and written into. may be shared by other
 * [AbstractOutputStream]s.
 */
abstract class AbstractOutputStream:OutputStream()
{
    /**
     * convenience method
     */
    final override fun write(b:Int)
    {
        write(byteArrayOf(b.toByte()))
    }

    /**
     * convenience method
     */
    final override fun write(b:ByteArray)
    {
        write(b,0,b.size)
    }

    /**
     * generates a header for the passed data using [makeHeader], then writes
     * the header followed by the passed data out the [multiplexedOutputStream].
     * [off] and [len] specify an inclusive range of indices of data that will
     * be written from [b] out the [multiplexedOutputStream].
     *
     * @param b [ByteArray] of data that will be sent from.
     * @param off specifies a starting index in [b].
     * @param len specifies an ending index in [b].
     */
    final override fun write(b:ByteArray,off:Int,len:Int) = synchronized(this)
    {
        state.write(b,off,len)
    }

    /**
     * closes the stream. once closed, any subsequent calls to write will throw
     * an [IOException]. any ongoing calls to write immediately throw an
     * [IOException].
     */
    final override fun close() = synchronized(this)
    {
        state.close()
    }

    abstract fun doWrite(b:ByteArray,off:Int,len:Int)

    abstract fun doClose()

    private var state:State = Opened()

    private interface State
    {
        fun write(b:ByteArray,off:Int,len:Int)
        fun close()
    }

    inner class Opened:State
    {
        override fun write(b:ByteArray,off:Int,len:Int)
        {
            doWrite(b,off,len)
        }

        override fun close()
        {
            state = Closed()
            doClose()
        }
    }

    inner class Closed:State
    {
        override fun write(b:ByteArray,off:Int,len:Int)
        {
            throw IOException("stream is closed; cannot write.")
        }

        override fun close()
        {
            throw IOException("already closed!")
        }
    }
}
