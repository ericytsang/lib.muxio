package muxio.lib

import java.io.IOException
import java.io.InterruptedIOException
import java.io.OutputStream
import kotlin.concurrent.currentThread

/**
 * used to multiplex and write data into the underlying shared
 * [multiplexedOutputStream] that other [MultiplexingOutputStream]s also write
 * into. The data written by this stream into the [multiplexedOutputStream] is
 * always immediately preceded by headers generated by the [headerFactory].
 *
 * @param multiplexedOutputStream the [OutputStream] that data should be
 * multiplexed and written into. may be shared by other
 * [MultiplexingOutputStream]s.
 */
open class MultiplexingOutputStream(
    val multiplexedOutputStream:OutputStream):
    OutputStream()
{
    /**
     * true when the socket is closed; false otherwise.
     */
    var isClosed = false
        private set

    /**
     * reference to the thread that is writing into this
     * [MultiplexingOutputStream] because the thread could be blocked; may need
     * interrupting if [close] is called.
     */
    private var writeThread:Thread? = null

    /**
     * convenience method
     */
    override fun write(b:Int)
    {
        write(byteArrayOf(b.toByte()))
    }

    /**
     * convenience method
     */
    override fun write(b:ByteArray)
    {
        write(b,0,b.size)
    }

    /**
     * generates a header for the passed data using [makeHeader], then writes
     * the header followed by the passed data out the [multiplexedOutputStream].
     * [off] and [len] specify an inclusive range of indices of data that will
     * be written from [b] out the [multiplexedOutputStream].
     *
     * @param b [ByteArray] of data that will be sent from.
     * @param off specifies a starting index in [b].
     * @param len specifies an ending index in [b].
     */
    override fun write(b:ByteArray,off:Int,len:Int)
    {
        try
        {
            writeThread = currentThread

            if (!isClosed)
            {
                val header = makeHeader(b,off,len)
                synchronized(multiplexedOutputStream)
                {
                    multiplexedOutputStream.write(header)
                    multiplexedOutputStream.write(b,off,len)
                }
            }
            else
            {
                throw IOException("stream is closed; cannot write.")
            }
        }

        // catch InterruptedException as it might have been thrown as a
        // result of "close" being called
        catch(ex:InterruptedException)
        {
            if (isClosed)
            {
                throw IOException("stream is closed; cannot write.")
            }
            else
            {
                throw InterruptedIOException()
            }
        }

        // set write thread to null, so we don't interrupt it unnecessarily
        finally
        {
            writeThread = null
        }
    }

    /**
     * closes the stream. once closed, any subsequent calls to write will throw
     * an [IOException]. any ongoing calls to write immediately throw an
     * [IOException].
     */
    override fun close()
    {
        isClosed = true
        writeThread?.interrupt()
    }

    /**
     * used to generate a header that will precede the passed payload for when
     * it is sent in the near future. [off] and [len] specify an inclusive range
     * of indices of data that will be written from [b] out the
     * [multiplexedOutputStream].
     *
     * @param b [ByteArray] of data that will be sent from.
     * @param off specifies a starting index in [b].
     * @param len specifies an ending index in [b].
     */
    open fun makeHeader(b:ByteArray,off:Int,len:Int):ByteArray = ByteArray(0)
}
